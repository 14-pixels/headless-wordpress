<?php
/**
 * Auth Instance.
 *
 * @package WebDevStudios\SSO
 * @since   1.0.0
 */

namespace WebDevStudios\SSO;

use WP_User;
use WP_Error;

/**
 * Does authentication directly to Google or
 * routes through a proxy depending on configuration.
 *
 * @author Justin Foell
 * @since  1.0.0
 */
class Auth {

	/**
	 * Construct.
	 *
	 * @author Justin Foell
	 * @since  1.0.0
	 */
	public function __construct() {
		$this->hooks();
	}

	/**
	 * Attach to relevant WP hooks.
	 *
	 * @author Justin Foell
	 * @since  1.0.0
	 */
	private function hooks() {
		add_action( 'authenticate', array( $this, 'authenticate' ), 9, 1 );
		add_action( 'init', array( $this, 'login_expired_sso_session' ), 1 );
		add_filter( 'allowed_redirect_hosts', array( $this, 'allowed_redirect_hosts' ) );
		add_filter( 'wp_authenticate_user', array( $this, 'prevent_sso_user_direct_login' ) );
		add_action( 'admin_notices', array( $this, 'first_login_message_success' ) );

		// Clean up nonce transients generated by the client via cron.
		add_action( 'admin_init', array( $this, 'setup_purge_transients_cron' ) );
		add_action( 'wds_sso_purge_nonce_transients_cron', array( $this, 'purge_transients' ) );
	}

	/**
	 * Logout an SSO User if their session has expired.
	 *
	 * @author Aubrey Portwood
	 * @since  1.0.0
	 *
	 * @return void Early bails for non SSO users.
	 */
	public function login_expired_sso_session() {
		if ( ! is_user_logged_in() ) {
			return;
		}

		if ( ! app()->user->is_sso_user() ) {

			// Only re-authenticate SSO users.
			return;
		}

		/**
		 * Stop the session expiration logout.
		 *
		 * This was a quick fix for:
		 *
		 * https://github.com/WebDevStudios/project-maintainn.com/issues/69
		 * https://github.com/WebDevStudios/wds-sso/issues/221
		 *
		 * Seemed the session was expiring too-soon for some reason on maintainn.com,
		 * this allowed us to disable it until we can figure out why this is happening.
		 *
		 * If you can't filter this you can also set the constant WDS_SSO_SKIP_EXPIRED_SESSION_LOGOUT
		 *
		 * @author Aubrey Portwood <aubrey@webdevstudios.com>
		 * @since  1.3.2
		 *
		 * @var bool
		 */
		$skip = apply_filters( 'wds_sso_skip_expired_session_logout', defined( 'WDS_SSO_SKIP_EXPIRED_SESSION_LOGOUT' ) && WDS_SSO_SKIP_EXPIRED_SESSION_LOGOUT ? true : false );
		if ( $skip ) {
			return;
		}

		// Get the user's session.
		$user_id = get_current_user_id();
		$session = get_transient( app()->user->get_session_key( $user_id ) );

		// If the user has this transient set, they can continue to do actions (or are in DEV mode).
		$session_verified = absint( $session ) === $user_id;

		// The user's session has expired and debug hasn't been set.
		if ( ! $session_verified ) {

			// Change their password, just in case they have it locally or something somehow.
			wp_set_password( wp_hash( random_bytes( 100 ), 'nonce' ), get_current_user_id() );

			// Log the user out and don't allow another action.
			wp_logout();
			return;
		}

		/*
		 * When a user is active within the session's timeframe,
		 * extend that time frame from the current time.
		 *
		 * This allows users who need to have extended active
		 * sessions open (think wds migrations) to continue to be
		 * active as long as they need.
		 */
		app()->user->start_session();
	}

	/**
	 * How long the session should last.
	 *
	 * Once a SSO user logs in, how long can they be active
	 * before having to re-authenticate using Google.
	 *
	 * If they've been removed from Google, they shouldn't be able
	 * to re-authenticate and once this expires they shouldn't be able
	 * to log back in.
	 *
	 * @author Aubrey Portwood
	 * @since  1.0.0
	 * @since  1.2.5 Life of session time increased to 8 hours
	 *               and max time reduced to a week when using
	 *               filtered value.
	 *
	 * @return int The number of seconds it should last.
	 */
	public function get_session_time() {

		// Default.
		$seconds = HOUR_IN_SECONDS * 8;

		/**
		 * Filter how long SSO sessions are.
		 *
		 * This essentially sets how long a WDS SSO user
		 * gets to do things on the site before they have
		 * to re-authenticate via Google.
		 *
		 * @author Aubrey Portwood
		 * @since  1.0.0
		 *
		 * @var int Seconds of how long.
		 */
		$filtered = apply_filters( 'wds_sso_session_time', $seconds );

		// Only if the filtered value is valid, and is not longer than a year.
		if ( is_int( $filtered ) && $filtered < WEEK_IN_SECONDS ) {

			// Use the filtered value.
			return absint( $filtered );
		}

		// Use the default.
		return $seconds;
	}

	/**
	 * Are we in debug mode?
	 *
	 * @author Aubrey Portwood
	 * @since  1.0.0
	 *
	 * @return boolean True if WDS_SSO_DEBUG is set.
	 */
	private function debug() {
		/*
		 * How to set debug mode.
		 *
		 *   define( 'WDS_SSO_DEBUG', true );
		 *
		 * Set this in wp-config.php on your locals to entirely disable
		 * the expiration of WDS SSO users.
		 */
		return defined( 'WDS_SSO_DEBUG' ) && true === WDS_SSO_DEBUG;
	}

	/**
	 * Get the GET state.
	 *
	 * @author Aubrey Portwood <aubrey@webdevstudios.com>
	 * @since  2.0.0
	 *
	 * @return string The state.
	 */
	private function get_state() {
		$state = filter_input( INPUT_GET, 'state' );
		return is_string( $state ) ? $state : '';
	}

	/**
	 * WP authentication filter.
	 *
	 * Returning a valid user here effectively logs that account in.
	 *
	 * @author Justin Foell, Jay Wood, Aubrey Portwood
	 * @since  1.0.0
	 *
	 * @param null|WP_User $user     If there is an error, this will be null, WP_User otherwise.
	 *
	 * @return WP_User|WP_Error User that should be logged in, error otherwise (will be displayed).
	 */
	public function authenticate( $user ) {

		if ( empty( $this->get_state() ) ) { // @codingStandardsIgnoreLine Only checking for existence.
			return $user;
		}

		// Decode state.
		try {
			$state = app()->shared->decode_state( $this->get_state() ); // @codingStandardsIgnoreLine: nonce verified after decode.
		} catch ( Exception $e ) {
			return WP_Error( 'wds-sso', $e->getMessage() );
		}

		// Check nonce first.
		if ( ! $this->verify_nonce( $state['nonce'] ) ) {

			// Translators: A message to show the nonce provided was invalid.
			return new WP_Error( 'wds-sso', esc_html__( 'Invalid nonce', 'wds-sso' ) );
		}

		if ( empty( $state['email'] ) ) {

			// Translators: A message to show the email provided was blank.
			return new WP_Error( 'wds-sso', esc_html__( 'Missing email.', 'wds-sso' ) );
		}

		if ( ! is_email( $state['email'] ) ) {
			// Translators: A message to show the email provided was invalid.
			return new WP_Error( 'wds-sso', sprintf( esc_html__( 'Invalid email: %s.', 'wds-sso' ), $state['email'] ) );
		}

		if ( ! app()->roles->is_email_in_auth_domain( $state['email'] ) ) {

			$email_parts = explode( '@', $state['email'], 2 );
			return new WP_Error(
				'wds-sso',
				sprintf(
					// Translators: A message to show the email is not in the approved domain list.
					esc_html__( 'Invalid auth domain: %s.', 'wds-sso' ),
					end( $email_parts )
				)
			);
		}

		// Log in.
		$user = get_user_by( 'email', $state['email'] );

		if ( ! $user instanceof WP_User ) {

			// Attempt user account creation.
			$user_id = app()->user->create_user( array( 'user_email' => $state['email'] ) );

			if ( empty( $user_id ) || ! is_numeric( $user_id ) ) {

				// Translators: A message to show the email provided was not found.
				return new WP_Error( 'wds-sso', sprintf( esc_html__( 'User not found for email %s', 'wds-sso' ), $state['email'] ) );
			}

			$user = get_user_by( 'id', $user_id );
		} else {

			// Reset the user's password every-time they login.
			app()->user->reset_password( $user->ID );

			// Do this to re-instate a possibly degraded role on an SSO user.
			app()->user->set_sso_user( $user->ID );
		}

		// Start the users session when they successfully authenticate via Google.
		app()->user->start_session( $user->ID );

		return $user;
	}

	/**
	 * Prevent SSO users from using WordPress log in.
	 *
	 * @author Pavel Korotenko
	 * @since  1.0.0
	 *
	 * @param null|WP_User $user     If there is an error, this will be null, WP_User otherwise.
	 *
	 * @return WP_User|WP_Error User that should be logged in, error otherwise (will be displayed).
	 */
	public function prevent_sso_user_direct_login( $user ) {
		// Bail if SSO user tries to log in with WordPress password, instead of using Google account.
		if ( empty( $user->ID ) ) {
			return $user;
		}

		// Check if settings not set, or not an SSO user.
		if ( ! app()->settings->is_settings_set() || ! app()->user->is_sso_user( $user->ID ) ) {
			return $user;
		}

		// Translators: A message to show WDS login requirement.
		return new WP_Error( 'wds-sso', esc_html__( 'Please use your SSO Login.', 'wds-sso' ) );
	}

	/**
	 * Login URL to proxy.
	 *
	 * @author Justin Foell
	 * @since  1.0.0
	 *
	 * @return string URL.
	 */
	public function get_login_url() {
		$http = app()->shared->http_enabled();

		/*
		 * Value of redirect_to takes the user back to the request URI (after authentication at wp-login.php).
		 * Needed for wp_login_form() which may be on the front end. Force this to HTTPS so the GET string is
		 * encrypted (no matter the certificate state).
		 */
		$redirect_to = app()->shared->get_scheme() . '://' . $_SERVER['HTTP_HOST'] . $_SERVER['REQUEST_URI'];

		// Remove 'loggedout' from redirect URL to prevent authorization then immediate log-out or redisplay of "You are now logged out".
		$redirect_to = remove_query_arg( array( 'loggedout' ), $redirect_to );

		if ( ! is_ssl() && ! $http ) {

			// If we're not currently on SSL, link to the login form on HTTPS, and note we forced it.
			return add_query_arg( 'sso_force_https', 'yes', $redirect_to );
		}

		// If we're on the login page, we've likely been redirected already and had redirect_to added.
		if ( app()->shared->is_login() ) {
			$redirect_to = $this->get_original_redirect_to( $redirect_to );
		}

		// Remove 'sso_force_https' to clean up URL after nag.
		$redirect_to = remove_query_arg( array( 'sso_force_https' ), $redirect_to );

		// Don't set redirect_to to wp-login.php if we're already on wp-login.php.
		$redirect_to = wp_login_url() === $redirect_to ? '' : $redirect_to;

		$url = wp_login_url( $redirect_to );

		// Always redirect to HTTPS wp-login.php.
		$url = $http
			? set_url_scheme( $url, 'http' )
			: set_url_scheme( $url, 'https' );

		// Get domain mapping settings.
		$domains = app()->settings->get_auth_domains();

		$hd = 1;

		// If there's more than one hosted domain parameter, set hd query param to 0.
		if ( is_array( $domains ) && 1 < count( $domains ) ) {
			$hd = 0;
		}

		// Add state information to URL.
		$state = array(
			'nonce'    => $this->create_nonce(),

			'redirect' => remove_query_arg( array(
				'loggedout',
				'reauth',
				'state',
			), $url ),

			'hd'       => $hd,
			'email'    => null,
		);

		$state     = app()->shared->encode_state( $state );
		$proxy_url = $this->get_proxy_url();

		if ( empty( $proxy_url ) ) {
			/*
			 * This means the proxy URL is not set up or is not HTTPS.
			 *
			 * @todo Maybe don't enqueue/print the login button/link, or present an error.
			 */
			return '';
		}

		return esc_url_raw( add_query_arg( array( 'state' => urlencode( $state )  ), $proxy_url ) );  // @codingStandardsIgnoreLine Single assoc array, no need to complain.
	}

	/**
	 * Add allowed hosts for safe redirect.
	 *
	 * @author Justin Foell
	 * @since  1.0.0
	 *
	 * @param  array $hosts Hosts we are safe to redirect to.
	 *
	 * @return array $hosts Hosts array with additional entries.
	 */
	public function allowed_redirect_hosts( $hosts ) {
		app()->shared->add_host( $hosts, $this->get_proxy_url_definition() );
		return $hosts;
	}

	/**
	 * Set up cron to purge SSO nonce transients hourly.
	 *
	 * @author Justin Foell
	 * @since  1.0.0
	 */
	public function setup_purge_transients_cron() {

		// Schedule the cron job to purge all expired transients.
		if ( ! wp_next_scheduled( 'wds_sso_purge_nonce_transients_cron' ) ) {
			wp_schedule_event( time(), 'hourly', 'wds_sso_purge_nonce_transients_cron' );
		}
	}

	/**
	 * Purge old SSO nonce transients and their expire time.
	 *
	 * @author Justin Foell
	 * @since  1.0.0
	 */
	public function purge_transients() {
		global $wpdb;

		// Give a 15 minute buffer to anyone using a nonce right at the edge of the window.
		// phpcs:disable WordPress.DB.PreparedSQLPlaceholders.LikeWildcardsInQuery -- SQL OK, this LIKE doesn't use variables.
		$wpdb->query( $wpdb->prepare(
			"DELETE FROM {$wpdb->options}
				WHERE
				(
					option_name LIKE '_transient_timeout_wds_sso_nonce_%%' OR
					option_name LIKE '_transient_wds_sso_nonce_%%'
				)
				AND option_value < %d",
			time() - ( 15 * MINUTE_IN_SECONDS ) ) );
		// phpcs:enable WordPress.DB.PreparedSQLPlaceholders.LikeWildcardsInQuery
	}

	/**
	 * Maybe add https:// to wp-admin URL.
	 *
	 * @author Aubrey Portwood
	 * @since  1.1.0
	 *
	 * @param  string $url The possible wp-admin URL.
	 * @return string      The URL, with https if it's the admin.
	 */
	private function maybe_https_the_wp_admin( $url ) {
		if ( stristr( $url, 'wp-admin' ) ) {

			if ( app()->shared->http_enabled() ) {
				return str_replace( 'https://', 'http://', $url );
			}

			// If we're redirecting back to the admin, always use https which we forced earlier.
			return str_replace( 'http://', 'https://', $url );
		}

		return $url;
	}

	/**
	 * Find original redirect_to parameter after multiple redirects.
	 *
	 * @author Justin Foell
	 * @since  1.0.0
	 *
	 * @param  string $url The URL of the redirect_to argument.
	 * @return string Original redirect_to URL.
	 */
	private function get_original_redirect_to( $url ) {
		$redirect_to = '';
		$parts       = array();

		$query = wp_parse_url( $url, PHP_URL_QUERY );
		parse_str( $query, $parts );

		if ( ! empty( $parts['redirect_to'] ) ) {
			$redirect_to = $parts['redirect_to'];
		}

		// Recurse into this URL if it still has a redirect_to in it.
		if ( false !== strpos( $redirect_to, 'redirect_to' ) ) {
			$redirect_to = $this->get_original_redirect_to( $redirect_to );
		}

		// Always re-direct back to the site, but always come back to https, which we forced earlier.
		return $this->maybe_https_the_wp_admin( $redirect_to );
	}

	/**
	 * Create a true nonce with a one-hour transient.
	 *
	 * @see https://pantheon.io/blog/nonce-upon-time-wordpress
	 *
	 * @author Justin Foell
	 * @since  1.0.0
	 *
	 * @return string $nonce The nonce string.
	 */
	private function create_nonce() {

		// This should be cryptographically unique (uses wp_salt() & hash_hmac()).
		$nonce = app()->shared->generate_nonce();

		// Create a transient that expires in an hour, and contains the expiry time as its value for later comparison.
		$expire = current_time( 'timestamp' ) + HOUR_IN_SECONDS;
		set_transient( 'wds_sso_nonce_' . $nonce, $expire, HOUR_IN_SECONDS );

		return $nonce;
	}

	/**
	 * Verify our one-time server-side nonce.
	 *
	 * @author Justin Foell
	 * @since  1.0.0
	 *
	 * @param string $nonce The nonce to verify.
	 *
	 * @return boolean True if verification passed.
	 */
	private function verify_nonce( $nonce ) {
		$verified = true;

		// Make sure it is recognized server-side and hasn't expired.
		$transient = 'wds_sso_nonce_' . $nonce;
		$expire    = get_transient( $transient );

		if ( current_time( 'timestamp' ) > $expire ) {
			$verified = false;
		}

		// Allow this to be verified exactly once.
		delete_transient( $transient );

		return $verified;
	}

	/**
	 * Returns proxy URL only if configured and HTTPS.
	 *
	 * @author Justin Foell
	 * @since 1.0.0
	 *
	 * @return string Proxy URL if configured and has HTTPS, empty string otherwise.
	 */
	public function get_proxy_url() {
		if ( app()->shared->http_enabled() ) {
			return str_replace( 'https://', 'http://', $this->get_proxy_url_definition() );
		}

		return str_replace( 'http://', 'https://', $this->get_proxy_url_definition() );
	}

	/**
	 * Get Proxy URL.
	 *
	 * @author Kailan W., Jay Wood
	 *
	 * @since 1.0.0
	 *
	 * @return string Return proxy URL.
	 */
	private function get_proxy_url_definition() {
		$sso_url = defined( 'WDS_SSO_PROXY_URL' ) && ! empty( WDS_SSO_PROXY_URL )

			// Use what they set.
			? WDS_SSO_PROXY_URL

			// Use the default.
			: add_query_arg( array( 'wds-sso' => 'true' ), wp_login_url() );

		return esc_url_raw( apply_filters( 'wds_sso_proxy_url', $sso_url ) );
	}

	/**
	 * Displays admin notice on the first login of the user.
	 *
	 * @author Pavel Korotenko
	 * @since  1.0.0
	 *
	 * @return void Return void if notice was displayed already or not valid user.
	 */
	public function first_login_message_success() {

		// Get current user.
		$user = wp_get_current_user();

		// Bail if not a valid user.
		if ( empty( $user->ID ) || ! is_numeric( $user->ID ) ) {
			return;
		}

		// Get user meta key for notice displayed.
		$notice_displayed = get_user_meta( $user->ID, 'wds_sso_notice_displayed', true );

		// Bail if we already displayed our notice or not SSO user.
		if ( ! app()->user->is_sso_user( $user->ID ) || $notice_displayed ) {
			return;
		}

		// Get user registration time.
		$registration_time = strtotime( $user->user_registered );

		// Get time now.
		$now = strtotime( 'now' );

		// Get time between user registration and now.
		$diff = $now - $registration_time;

		// Display this message for first 30 minutes after user creation.
		if ( $diff < 1800 ) {
			?>
			<div class="notice notice-success is-dismissible">
				<p><?php echo esc_html__( 'You did not have a user account, so we created one for you. Be sure you update your profile', 'wds-sso' ); ?>
				<a href="<?php echo esc_url( admin_url( 'profile.php' ) ); ?>"><?php echo esc_html__( 'here.', 'wds-sso' ); ?></a></p>
			</div>
			<?php
		}

		// Save to user meta that we already displayed this notice.
		add_user_meta( $user->ID, 'wds_sso_notice_displayed', true );
	}
}
